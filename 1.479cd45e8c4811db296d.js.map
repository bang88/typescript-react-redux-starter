{"version":3,"sources":["webpack:///./src/routes/Counter/containers/CounterContainer.ts","webpack:///./src/routes/Counter/modules/counter.ts","webpack:///./src/routes/Counter/components/Counter.tsx"],"names":[],"mappings":";;;;;;;;;;AAAA,yCACC;AAAD,qCAOC;;;;;AAAD,qCAMC;;;;AAAD,KAAuB,oBAAG,2BAAS;AAC3B;AACK;AAAE,oBAAoB,SAAC,UAAS,UAAI;;AAClC;AAAE,oBAAoB,SAAC,UAEtC;;AAJS;AAIR;AAED,KAAqB,2CAAc;AAAX;AACf,kBAAO,MACd;AAFkC;;AAsBpC;mBAAe,cAAO,QAAgB,iBAAoB,mBAAC,UAAQ,S;;;;;;;;;;ACzC5B;;;;;;;AAC1B,SAAiB,oBAIS;;;;AACvC;SAAgC,8DAAI;;AAC5B;AACA,eAAE,QAAiB;AAChB,kBAEX;AAJS;AAIR;AALe,SAAS,YAae;;;;;;;;AAE3B,SAAW,cAAG;AACnB,YAAC,UAAS,UAAU;AAClB,oBAAY,QAAC,UAAQ;AACf,wBAAC;AACD,0BAAU,UAAW,WAAU;AAEzC;AAAC,gBACH;AACF,UANS;AAOX;AAAC;AAEY,SAAO;AAClB,gBAAS;AACT,0BAKqC;AAPhB;;;;AAQvB,2CACG,QAAkB,6BAAQ,OAAQ;AAAd,YAAwB,QAAS,OAKjB;EALrC;;;;AAMF,KAAkB,eAAI;AACtB;SAA6C,8DAAe;SAAQ;;AAClE,SAAa,UAAkB,gBAAO,OAAM;AAEtC,YAAQ,UAAU,QAAM,OAAS,UACzC;AAAC;AAJD;mBAIC,e;;;;;;;;;;;;;;;;;;;;ACtDD,KAAiB,4BAAc;AAC/B,kCAOA;;;;;;;;;;;;;;;;AAEe,oBACH,oBAAI,aAEA,oBAAC,OAAG,wBAAe,KAAM,MAAe,8BAEvC,OAAM,UAAK,MAAU,WAAQ,SAAE;AACxB,4BAAM,MACd;AAAG,oBAFH,EAEsB,cAEtB,oBAAC,OAAM,UAAK,MAAQ,SACT,SAAM,KAAM,MAAa,eAGhD;AACH;;;;GAhB0B,MACjB;;AAiBV;mBAAuB,Q","file":"1.chunk.js","sourcesContent":["import { connect } from 'react-redux'\r\nimport { increment, doubleAsync } from '../modules/counter'\r\n\r\n/*  This is a container component. Notice it does not contain any JSX,\r\n    nor does it import React. This component is **only** responsible for\r\n    wiring in the actions and state necessary to render a presentational\r\n    component - in this case, the counter:   */\r\n\r\nimport Counter from '../components/Counter'\r\n\r\n/*  Object of action creators (can also be function that returns object).\r\n    Keys will be passed as props to presentational components. Here we are\r\n    implementing our wrapper around increment; the component doesn't care   */\r\n\r\nconst mapActionCreators = (dispatch) => {\r\n  return {\r\n    increment: (): void => dispatch(increment(1)),\r\n    doubleAsync: (): void => dispatch(doubleAsync())\r\n  }\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n  counter: state.counter\r\n})\r\n\r\n/*  Note:\r\n\r\n     mapStateToProps is where you should use `reselect` to create selectors, ie:\r\n\r\n    import { createSelector } from 'reselect'\r\n    const counter = (state) => state.counter\r\n    const tripleCount = createSelector(counter, (count) => count * 3)\r\n    const mapStateToProps = (state) => ({\r\n      counter: tripleCount(state)\r\n    })\r\n\r\n    Selectors can compute derived data,\r\n     allowing Redux to store the minimal possible state.\r\n    Selectors are efficient.\r\n     A selector is not recomputed unless one of its arguments change.\r\n    Selectors are composable. They can be used as input to other selectors.\r\n    https://github.com/reactjs/reselect    */\r\n\r\nexport default connect(mapStateToProps, mapActionCreators)(Counter)\r\n\n\n\n/** WEBPACK FOOTER **\n ** node_modules/tslint-loader!./src/routes/Counter/containers/CounterContainer.ts\n **/","// ------------------------------------\r\n// Constants\r\n// ------------------------------------\r\nexport const COUNTER_INCREMENT = 'COUNTER_INCREMENT'\r\n\r\n// ------------------------------------\r\n// Actions\r\n// ------------------------------------\r\nexport function increment (value = 1) {\r\n  return {\r\n    type: COUNTER_INCREMENT,\r\n    payload: value\r\n  }\r\n}\r\n\r\n/*  This is a thunk, meaning it is a function that immediately\r\n    returns a function for lazy evaluation. It is incredibly useful for\r\n    creating async actions, especially when combined with redux-thunk!\r\n\r\n    NOTE: This is solely for demonstration purposes. In a real application,\r\n    you'd probably want to dispatch an action of COUNTER_DOUBLE and let the\r\n    reducer take care of this logic.  */\r\n\r\nexport const doubleAsync = () => {\r\n  return (dispatch, getState) => {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        dispatch(increment(getState().counter))\r\n        resolve()\r\n      }, 200)\r\n    })\r\n  }\r\n}\r\n\r\nexport const actions = {\r\n  increment,\r\n  doubleAsync\r\n}\r\n\r\n// ------------------------------------\r\n// Action Handlers\r\n// ------------------------------------\r\nconst ACTION_HANDLERS = {\r\n  [COUNTER_INCREMENT]: (state, action) => state + action.payload\r\n}\r\n\r\n// ------------------------------------\r\n// Reducer\r\n// ------------------------------------\r\nconst initialState = 0\r\nexport default function counterReducer (state = initialState, action) {\r\n  const handler = ACTION_HANDLERS[action.type]\r\n\r\n  return handler ? handler(state, action) : state\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** node_modules/tslint-loader!./src/routes/Counter/modules/counter.ts\n **/","import * as React from 'react';\r\nimport {Button, Tag} from 'antd';\r\nimport { increment, doubleAsync } from '../modules/counter'\r\ninterface CounterProps extends React.Props<any> {\r\n    increment: typeof increment,\r\n    doubleAsync: typeof doubleAsync,\r\n    counter: number\r\n}\r\nclass Counter extends React.Component<CounterProps, any> {\r\n    render() {\r\n        return (\r\n            <div>\r\n\r\n                <Tag> Counter {this.props.counter}</Tag>\r\n\r\n                <Button type=\"primary\" onClick={() => {\r\n                    this.props.increment()\r\n                } }>increment</Button>\r\n\r\n                <Button type=\"ghost\"\r\n                    onClick={this.props.doubleAsync}>doubleAsync</Button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Counter;\r\n\n\n\n/** WEBPACK FOOTER **\n ** node_modules/tslint-loader!./src/routes/Counter/components/Counter.tsx\n **/"],"sourceRoot":""}